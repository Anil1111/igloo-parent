<?xml version="1.0" encoding="UTF-8"?>
	<!--
	- Root application context
-->
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
	xmlns:lang="http://www.springframework.org/schema/lang" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
		http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd
		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
		http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd">

	<!-- SCAN DES PACKAGES -->
	<context:component-scan base-package="fr.openwide" />

	<!-- INJECTION PAR ANNOTATION -->
	<context:annotation-config />

	<!-- CONFIGURATION -->
	<bean id="configurer"
		class="fr.openwide.core.spring.config.OwPropertyPlaceholderConfigurer">
		<property name="locations">
			<list>
				<value>classpath:owsi-hibernate.properties</value>
			</list>
		</property>
		<property name="ignoreResourceNotFound" value="true" />
	</bean>

	<!-- DB CONNEXION -->
	<!--
		2 datasources are needed because HibernateTransactionManager and
		DataSourceTransactionManager each bind connection resource on the
		thread with the datasource object as key. So if the transactions
		overlap, the transaction manager complains that value is already
		registered for given datasource
	-->
	<bean id="owsi-hibernate.datasource.hibernate" class="com.mchange.v2.c3p0.ComboPooledDataSource"
		p:driverClass="${db.driverClass}" p:jdbcUrl="${db.jdbcUrl}" p:user="${db.user}"
		p:password="${db.password}" p:initialPoolSize="${db.initialPoolSize}"
		p:minPoolSize="${db.minPoolSize}" p:maxPoolSize="${db.maxPoolSize}"
		p:preferredTestQuery="SELECT 1" p:testConnectionOnCheckin="true"
		p:idleConnectionTestPeriod="300" destroy-method="close" />

	<bean id="sessionFactory"
		class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean">
		<property name="dataSource" ref="owsi-hibernate.datasource.hibernate" />
		<property name="hibernateProperties">
			<props>
				<prop key="hibernate.dialect">${db.dialect}</prop>
				<prop key="hibernate.show_sql">false</prop>
				<prop key="hibernate.format_sql">false</prop>
				<prop key="hibernate.cache.use_second_level_cache">true</prop>
				<prop key="hibernate.cache.use_query_cache">true</prop>
				<prop key="hibernate.cache.use_structured_entries">true</prop>
				<prop key="hibernate.cache.provider_class">org.hibernate.cache.EhCacheProvider</prop>
				<prop key="hibernate.cache.provider_configuration_file_resource_path">/ehcache-hibernate.xml</prop>
				<prop key="hibernate.generate_statistics">true</prop>
				<prop key="hibernate.bytecode.use_reflection_optimizer">true</prop>
				<prop key="hibernate.search.default.directory_provider">org.hibernate.search.store.FSDirectoryProvider</prop>
				<!--
					En cas d'utilisation d'Hibernate Search (hibernate search est un outil permettant la mise à jour
					et l'exploitation d'un index lucene à partir d'une base de données relationnelle.
					<prop
					key="hibernate.search.default.indexBase">${lucene.index.path}</prop>
				-->
			</props>
		</property>
		
		<!-- Cette propriété indique les paquets contenant les entités -->
		<property name="packagesToScan">
			<list>
				<value>fr.openwide.hibernate.*.business.*.model</value>
			</list>
		</property>
		<!--
			En cas d'utilisation d'hibernate search
			<property name="eventListeners">
				<map>
					<entry key="post-insert">
						<set>
							<ref bean="fullTextIndexEventListener" />
						</set>
					</entry>
					<entry key="post-update">
						<set>
							<ref bean="fullTextIndexEventListener" />
						</set>
					</entry>
					<entry key="post-delete">
						<set>
							<ref bean="fullTextIndexEventListener" />
						</set>
					</entry>
				</map>
			</property>
		-->
	</bean>

	<!--
		En cas d'sutilisation d'hibernate search
		<bean id="fullTextIndexEventListener"
		class="org.hibernate.search.event.FullTextIndexEventListener" />
	-->
	
	<!-- Définition de la gestion des transactions -->
	<bean id="transactionManager"
		class="org.springframework.orm.hibernate3.HibernateTransactionManager"
		p:sessionFactory-ref="sessionFactory" />

	<aop:config>
		<aop:pointcut id="txPointCutDef"
			expression="execution(* fr.openwide..hibernate..business..service.*ServiceImpl.*(..))" />
		<aop:advisor advice-ref="txAdvice" pointcut-ref="txPointCutDef" />
	</aop:config>

	<tx:advice id="txAdvice" transaction-manager="transactionManager">
		<tx:attributes>
			<tx:method name="get*" read-only="true" />
			<tx:method name="list*" read-only="true" />
			<tx:method name="search*" read-only="true" />
			<tx:method name="*" read-only="false"
				rollback-for="fr.openwide.core.hibernate.exception.ServiceException" />
		</tx:attributes>
	</tx:advice>

</beans>